1. MultiThreading vs MultiProcessing vs MultiProgramming vs MultiTasking?------>

          a) MultiThreading- Java-da ən geniş istifadə olunan paralel işləmə mexanizmi MultiThreadingdir.
                             Java-da ipliklər (Thread sinifi və ya ExecutorService) eyni proses daxilində paralel
                             işləyən birdən çox tapşırığın həyata keçirilməsinə imkan verir. Thread-lər eyni yaddaş
                             sahəsini paylaşır və daha yüngül olduğu üçün MultiProcessing-dən daha çevikdir.

          b) MultiProcessing -MultiProcessing, Java-da birdən çox prosesin fərqli CPU-larda işlədilməsi deməkdir.
                              Əməliyyat sistemi bu prosesləri müxtəlif CPU-lar arasında bölə bilər.
                              Hər bir Java proqramı müstəqil bir proses kimi işləyə bilər, amma bu proseslər
                              fərqli JVM-lər üzərində işləyir.

          c) MultiProgramming -Java-da bir JVM (Java Virtual Machine) birdən çox proqramı işlədə bilər.
                               Hər bir Java proqramı fərqli bir prosesdir və bu proseslər paralel işləmək
                               üçün əməliyyat sistemi tərəfindən idarə olunur.

          d) MultiTasking  -Java-da birdən çox proses və ya thread icra olunaraq MultiTasking həyata keçirilir.
                            Bir JVM bir neçə Java proqramını idarə edə bilər və ya bir proqram daxilində bir
                            neçə tapşırığı paralel icra edə bilər. Java-da əsas MultiTasking mexanizmi
                            threads istifadə edir.

          Sxematik təsvir: |--- MultiProgramming — birdən çox Java proqramını eyni yaddaşa yükləyir.

                               |--- MultiTasking — bir JVM-də birdən çox tapşırıq icra edir
                                    (MultiThreading istifadə edə bilər).

                                    |--- MultiProcessing — fərqli CPU-larda birdən çox proses
                                         (hər proses fərqli JVM-lərdə işləyə bilər).

                                            |--- MultiThreading — hər proses daxilində birdən çox thread icra olunur.

2. Concurrency və Parallelism nədir? Onlar arasındakı fərqlər nələrdir?

        Concurrency  nədir? --->
        Concurrency, bir proqramın eyni zamanda birdən çox tapşırıq üzərində işləmə qabiliyyətidir,
        amma bu tapşırıqlar mütləq həqiqi olaraq eyni anda icra olunmaya bilər. Bu o deməkdir ki, tapşırıqlar
        bir-birini qısa müddətlər üçün "dayandıraraq" icra olunur. Yəni Concurrency ilə bir tapşırıq bitmədən
        digərinə keçilir və bu keçid o qədər sürətli olur ki, sanki tapşırıqlar eyni anda işləyirmiş kimi görünür.
        Amma əslində, bu tapşırıqlar bir CPU-da növbəli şəkildə icra olunur. Bu növbəli keçid mexanizmi resurslardan
        effektiv istifadəni təmin edir.

        Misal ilə izah:
        Təsəvvür et ki, sənin bir aşpazın var və o həm yemək bişirir, həm də salat hazırlayır. Aşpaz yeməyi bişirərkən
        qazanı qaynamağa qoyub, o vaxtda salat kəsməyə başlayır. Sonra yenidən yeməyi qarışdırmağa qayıdır. Yəni, aşpaz
        eyni anda iki işlə məşğul olmur, amma çox sürətli keçidlər edir. Bu vəziyyət Concurrency ilə bənzəyir.

        Java-da Concurrency təmin edən mexanizmlər (məsələn, Thread, Runnable, ExecutorService) tapşırıqları
        bu şəkildə növbə ilə icra edə bilər. Bir nüvə olduğu təqdirdə, birdən çox thread eyni anda işləmir.
        Hər bir thread qısa müddət ərzində işləyir, sonra dayandırılıb digəri işə başlayır.

        Parallelism nədir? --->
        Parallelism isə birdən çox tapşırığın eyni vaxtda, yəni eyni anda bir neçə CPU və ya nüvə (core) üzərində
        həqiqi şəkildə icra olunmasını nəzərdə tutur. Paralel işləmə üçün çox nüvəli və ya çox CPU-lu sistemlər
        lazımdır, çünki tapşırıqlar tam olaraq eyni vaxtda yerinə yetirilir.
        Məsələn, iki aşpazın olduğunu düşün. Bir aşpaz yemək bişirir, digər aşpaz isə eyni anda salat hazırlayır.
        Bu vəziyyət Parallelismdir, çünki hər iki tapşırıq eyni vaxtda icra olunur və resurslar paralel istifadə olunur.


Race condition nədir? -------------->

       Yuxarda qeyd olunduğu kimi multithreading zamanı thread-lər eyni yaddaş sahəsini paylaşır.
       Bu da bəzi problemlərə səbəb olurki, bu problemlərdən biri də race condition-dur.
       Race condition- thread-lər yaddaş sahəsindəki dəyişənə eyni anda müraciət edib onu dəyişməyə çalışır.
       Məsələn : Bank hesabında 300 AZN pul var. 2 müxtəlif istifadəçi bu balansa pul transfer edir.
       Birinci müştəri balansa 50 AZN, ikinci isə 100 AZN pul transfer edir. Bu prossesdə hər iki thread
       balance dəyişəninə eyni anda müraciət etdiyi üçün 300 qiymətini götürür və əlavə olunacaq dəyər bu qiymətin
       üzərinə gəlir:
          Birinci müştəri : 300+ 50
          İkinci müştəri : 300+100
          Bu halda hesabdaki balance 350 və ya 400 görsənəcək (Threadlərin hansinin sonda işini bitirdiyindən asılı olaraq)
          Halbuki belə olmalı idi : 300+50+100 (və ya 300+100+50)


Race condition-un qarşısını almaq üçün Lock mechanism-lər tədbiq olunur ---->
     1) Atomic classes
     2) Intrinsic Locks (Monitor Locks)-Bunlar synchronized bloklar və metodlarla təmin olunur.
     3) ReentrantLock
     4) Cycle Barier

a)Atomik Əməliyyat Nədir?
 -----> Bir dəyişən atomik elan edildikdə, hər hansı bir thread bu dəyişəni oxuduqda o
        avtomatik bloklanır və thread-in işi bitənə qədər başqa thread-ın bu dəyişəni istifadə
        etməsinə icazə vermir.Java-da atomik əməliyyatları təmin etmək üçün java.util.concurrent.atomic
        paketində müxtəlif  siniflər mövcuddur. Bu siniflər atomik dəyişənlər üzərində əməliyyatlar aparmaq üçün xüsusi
        alqoritmlərdən istifadə edirlər.
        Nümunə :  private AtomicInteger balance = new AtomicInteger(1000);
        Qeyd : custom class-larda AtomicReferance istifade edilir.
        AtomicReference<Person> atomicPerson = new AtomicReference<>(new Person("Gulshan"));

b)Monitor Locks nədir?
----> Java-da monitor lock synchronized açar sözü ilə həyata keçirilir. synchronized açar sözü
      iki şəkildə istifadə edilə bilər:
      1.synchronized methods
      2.synchronized blocks


----> Monitor Locks (və ya sadəcə Monitors) Java-da çox istifadə olunan sinxronizasiya mexanizmidir
      və hər bir obyekt üçün daxil olan daxili bir kilid (lock) kimi işləyir. Monitor kilidləri (locks)
      Java-da thread-lər arası (multithreading) təhlükəsizliyi təmin etmək üçün istifadə olunur. Bir neçə
      thread eyni obyekt üzərində işlədikdə, obyektin vəziyyətinin (state) dəyişikliyinin ardıcıl olmasını təmin
      etmək üçün monitor kilidləri tətbiq edilir.

----> Java-da hər obyektin daxili bir monitoru vardır. Bu monitorun kilidi müəyyən kod bloku və ya metod sinxronizasiya
      olunmuş şəkildə işlədikdə aktivləşir. Yəni, bir thread monitor kilidini əldə edəndə, digər thread-lər həmin monitoru
      əldə edə bilmir və kodun həmin bölməsini icra etmək üçün gözləməli olur.



